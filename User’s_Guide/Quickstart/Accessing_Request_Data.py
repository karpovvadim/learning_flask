# Accessing Request Data (Доступ к данным запроса)

# Для веб-приложений очень важно реагировать на данные, которые клиент отправляет на сервер.
# В Flask эта информация предоставляется глобальным объектом запроса. Если у вас есть
# некоторый опыт работы с Python, вам может быть интересно, как этот объект может быть
# глобальным и как Flask удается по-прежнему быть потокобезопасным. Ответ — локальные
# контексты:
# локальные контексты

# Инсайдерская информация:
# Если вы хотите понять, как это работает и как реализовать тесты с локальными переменными
# контекста, прочтите этот раздел, в противном случае просто пропустите его.

# Некоторые объекты в Flask являются глобальными объектами, но не обычными. Эти объекты на
# самом деле являются прокси для объектов, которые являются локальными для определенного
# контекста. Как глоток. Но это на самом деле довольно легко понять.
# Представьте, что контекст является потоком обработки. Приходит запрос, и веб-сервер решает
# создать новый поток (или что-то еще, базовый объект способен работать с системами
# параллелизма, отличными от потоков). Когда Flask начинает внутреннюю обработку запросов,
# он определяет, что текущий поток является активным контекстом, и привязывает текущее
# приложение и среду WSGI (Web Server Gateway Interface) к этому контексту (потоку). Он делает это интеллектуальным
# способом, так что одно приложение может вызывать другое приложение без нарушения работы.
#
# Итак, что это значит для вас? По сути, вы можете полностью игнорировать это, если только
# вы не занимаетесь модульным тестированием. Вы заметите, что код, который зависит от объекта
# запроса, внезапно сломается, потому что объект запроса отсутствует. Решение заключается
# в самостоятельном создании объекта запроса и привязке его к контексту. Самым простым
# решением для модульного тестирования является использование менеджера контекста
# test_request_context(). В сочетании с оператором with он свяжет тестовый запрос, чтобы вы
# могли с ним взаимодействовать. Вот пример:
from os import environ

from flask import Flask, render_template
from flask import request

app = Flask(__name__)


@app.route('/hello/', methods=['GET', 'POST'])
@app.route('/hello/<name>')
def hello(name=None):
    if request.method == 'POST':
        return "do_the_login()"
    else:
        return render_template('hello.html', name=name)


with app.test_request_context('/hello', method='POST'):
    # now you can do something with the request until theend of the with block,
    # such as basic assertions:
    # теперь вы можете что-то делать с запросом до конца блока with,
    # например базовые утверждения:
    assert request.path == '/hello'   # утверждать
    assert request.method == 'POST'

if __name__ == '__main__':
    app.run(debug=True, host='localhost', port=5005)

# Другая возможность — передать всю среду WSGI методу request_context():
with app.request_context(environ):
    assert request.method == 'POST'
