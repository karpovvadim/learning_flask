# Минимальное приложение Flask выглядит примерно так:

# 1. Сначала мы импортировали класс Flask. Экземпляр этого класса и будет вашим
# WSGI-приложением.
from flask import Flask

# 2. Далее мы создаём экземпляр этого класса. Первый аргумент - это имя модуля или
# пакета приложения. Если вы используете единственный модуль (как в этом примере), вам
# следует использовать __name__, потому что в зависимости от того, запущен ли код как
# приложение, или был импортирован как модуль, это имя будет разным ('__main__' или
# актуальное имя импортированного модуля соответственно). Это нужно, чтобы Flask знал,
# где искать шаблоны, статические файлы и прочее. Для дополнительной информации,
# смотрите документацию Flask.

app = Flask(__name__)


# 3. Далее, мы используем декоратор route(), чтобы сказать Flask, какой из URL должен
# запускать нашу функцию.

@app.route("/")
# 4. Функция возвращает сообщение, которое мы хотим отобразить в браузере пользователя.
# Тип содержимого по умолчанию — HTML, поэтому HTML в строке будет отображаться
# браузером.
def hello_world():
    return "<p>Hello, World!</p>"


# 5. Наконец, для запуска локального сервера с нашим приложением, мы используем функцию
# run(). Благодаря конструкции if __name__ == '__main__' можно быть уверенным, что
# сервер запустится только при непосредственном вызове скрипта из интерпретатора Python,
# а не при его импортировании в качестве модуля.
if __name__ == '__main__':
    app.run(debug=True, host='localhost', port=5005)

# Debug Mode
# Команда flask run может сделать больше, чем просто запустить сервер разработки.
# Включив режим отладки, сервер автоматически перезагрузится при изменении кода и покажет
# интерактивный отладчик в браузере, если во время запроса возникнет ошибка.
# Существует два способа включить отладку. Или установите флаг в объекте приложения:
"""
app.debug = True
app.run()"""

# Или передайте его как параметр при запуске:
"""app.run(debug=True)"""


# Оба метода вызовут одинаковый эффект.

# Внимание.
# Несмотря на то, что интерактивный отладчик не работает в многопоточных окружениях
# (что делает его практически неспособным к использованию на реальных рабочих серверах),
# тем не менее, он позволяет выполнение произвольного кода. Это делает его главной
# угрозой безопасности, и поэтому он никогда не должен использоваться на реальных
# «боевых» серверах.
