Define and Access the Database (Определение и доступ к базе данных)

Приложение будет использовать базу данных SQLite для хранения пользователей и сообщений.
Python поставляется со встроенной поддержкой SQLite в модуле sqlite3.
SQLite удобен тем, что не требует настройки отдельного сервера базы данных и встроен в Python.
Однако, если одновременные запросы пытаются выполнить запись в базу данных в одно и то же
время, они будут замедляться, поскольку каждая запись выполняется последовательно. Маленькие
приложения этого не заметят. Когда вы станете большим, вы можете захотеть переключиться на
другую базу данных.
В учебнике не рассматриваются подробности SQL. Если вы не знакомы с ним, документация по
SQLite описывает этот язык.

Connect to the Database (Подключиться к базе данных)

Первое, что нужно сделать при работе с базой данных SQLite (и большинством других библиотек
баз данных Python), — это создать к ней подключение. Любые запросы и операции выполняются с
использованием соединения, которое закрывается после завершения работы.
В веб-приложениях это соединение обычно привязано к запросу. Он создается в какой-то момент
при обработке запроса и закрывается перед отправкой ответа.
flaskr/db.py

import sqlite3
import click
from flask import current_app, g
def get_db():
    if 'db' not in g:
        g.db = sqlite3.connect(
            current_app.config['DATABASE'],
            detect_types=sqlite3.PARSE_DECLTYPES
        )
        g.db.row_factory = sqlite3.Row
    return g.db

def close_db(e=None):
    db = g.pop('db', None)
    if db is not None:
        db.close()

g — это специальный объект, уникальный для каждого запроса. Он используется для хранения
данных, к которым могут обращаться несколько функций во время запроса. Соединение сохраняется
и используется повторно вместо создания нового соединения, если get_db вызывается во второй
раз в том же запросе.

current_app — еще один специальный объект, указывающий на приложение Flask, обрабатывающее
запрос. Поскольку вы использовали фабрику приложений, при написании остального кода нет
объекта приложения. get_db будет вызываться, когда приложение будет создано и будет
обрабатывать запрос, поэтому можно использовать current_app.

sqlite3.connect() устанавливает соединение с файлом, на который указывает ключ конфигурации
DATABASE. Этот файл необязательно должен существовать, и не будет, пока вы не инициализируете
базу данных позже.

sqlite3.Row указывает соединению возвращать строки, которые ведут себя как словари. Это
позволяет получить доступ к столбцам по имени.

close_db проверяет, было ли создано соединение, проверяя, был ли установлен g.db. Если
соединение существует, оно закрывается. Далее вы сообщите своему приложению о функции
close_db в фабрике приложений, чтобы она вызывалась после каждого запроса.

Create the Tables (Создайте таблицы)

В SQLite данные хранятся в таблицах и столбцах. Их необходимо создать, прежде чем вы сможете
сохранять и извлекать данные. Flaskr будет хранить пользователей в таблице пользователей,
а сообщения — в таблице сообщений. Создайте файл с командами SQL, необходимыми для создания
пустых таблиц:
flaskr/schema.sql

DROP TABLE IF EXISTS user;
DROP TABLE IF EXISTS post;
CREATE TABLE user (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password TEXT NOT NULL
);
CREATE TABLE post (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  author_id INTEGER NOT NULL,
  created TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  title TEXT NOT NULL,
  body TEXT NOT NULL,
  FOREIGN KEY (author_id) REFERENCES user (id)
);

Добавьте функции Python, которые будут выполнять эти команды SQL, в файл db.py:
flaskr/db.py

def init_db():
    db = get_db()
    with current_app.open_resource('schema.sql') as f:
        db.executescript(f.read().decode('utf8'))

@click.command('init-db')
def init_db_command():
    init_db()
    click.echo('Initialized the database.')

open_resource() открывает файл, относящийся к пакету flaskr, что полезно, поскольку вы не
обязательно будете знать, где находится это местоположение при последующем развертывании
приложения. get_db возвращает соединение с базой данных, которое используется для выполнения
команд, считанных из файла.
click.command() определяет команду командной строки с именем init-db, которая вызывает
функцию init_db и показывает пользователю сообщение об успешном выполнении. Вы можете
прочитать Command Line Interface (Интерфейс командной строки), чтобы узнать больше
о написании команд.

Register with the Application (Зарегистрируйтесь в приложении)

Функции close_db и init_db_command должны быть зарегистрированы в экземпляре приложения;
в противном случае они не будут использоваться приложением. Однако, поскольку вы используете
фабричную функцию, этот экземпляр недоступен при написании функций. Вместо этого напишите
функцию, которая принимает приложение и выполняет регистрацию.
flaskr/db.py

def init_app(app):
    app.teardown_appcontext(close_db)
    app.cli.add_command(init_db_command)

app.teardown_appcontext() указывает Flask вызывать эту функцию при очистке после 
возврата ответа.
app.cli.add_command() добавляет новую команду, которую можно вызвать с помощью команды flask.

Импортируйте и вызовите эту функцию из фабрики. Поместите новый код в конец заводской
функции перед возвратом приложения.
flaskr/__init__.py

def create_app():
    app = ...
    # existing code omitted (существующий код опущен)
    from . import db
    db.init_app(app)
    return app

Initialize the Database File (Инициализировать файл базы данных)

Теперь, когда init-db зарегистрирован в приложении, его можно вызвать с помощью команды flask,
аналогичной команде запуска на предыдущей странице.

Примечание

Если вы все еще используете сервер с предыдущей страницы, вы можете либо остановить сервер,
либо запустить эту команду в новом терминале. Если вы используете новый терминал, не забудьте
перейти в каталог вашего проекта и активировать env, как описано в разделе «Установка».

Запустите команду init-db:

$ flask --app flaskr init-db
Initialized the database.

Теперь в папке экземпляра вашего проекта будет файл flaskr.sqlite.

Continue to Blueprints and Views.